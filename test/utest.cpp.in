#include <pluginlib/class_loader.h>
#include <gtest/gtest.h>

#include <console_bridge/console.h>

#include "test_base.h"

#define ROS_INFO(message, ...) logInform(message, ## __VA_ARGS__)

class CustomEnvironment
 : public ::testing::Environment
{
public:
  virtual ~CustomEnvironment()
  {}
  virtual void SetUp()
  {
    std::string ament_prefix_path = "@PLUGINLIB_TEST_PREFIX_PATH@";
    // set environment variable
#ifndef _WIN32
    int retcode = setenv("AMENT_PREFIX_PATH", ament_prefix_path.c_str(), 1);
#else
    errno_t retcode = _putenv_s("AMENT_PREFIX_PATH", ament_prefix_path);
#endif
    if (retcode) {
      throw std::runtime_error("Failed to set environment variable 'AMENT_PREFIX_PATH'");
    }
  }
};

TEST(PluginlibTest, unknownPlugin)
{
  pluginlib::ClassLoader<test_base::Fubar> test_loader("pluginlib", "test_base::Fubar");
  test_base::Fubar* foo = NULL;

  try {
    foo = test_loader.createUnmanagedInstance("pluginlib/foobar");
    foo->initialize(10.0);
  } catch (pluginlib::LibraryLoadException & ex) {
    SUCCEED();
    return;
  } catch (...) {
    FAIL() << "Uncaught exception";
  }
  ADD_FAILURE() << "Didn't throw exception as expected";
}


TEST(PluginlibTest, misspelledPlugin)
{
  pluginlib::ClassLoader<test_base::Fubar> bad_test_loader("pluginlib", "test_base::Fuba");
  test_base::Fubar* foo = NULL;

  try {
    foo = bad_test_loader.createUnmanagedInstance("pluginlib/foo");
    foo->initialize(10.0);
  } catch (pluginlib::LibraryLoadException & ex) {
    SUCCEED();
    return;
  } catch (...) {
    FAIL() << "Uncaught exception";
  }
  ADD_FAILURE() << "Didn't throw exception as expected";
}

TEST(PluginlibTest, invalidPackage)
{
  try {
    pluginlib::ClassLoader<test_base::Fubar> bad_test_loader("pluginlib_bad", "test_base::Fubar");
  } catch (pluginlib::LibraryLoadException & ex) {
    SUCCEED();
    return;
  } catch (...) {
    FAIL() << "Uncaught exception";
  }
  ADD_FAILURE() << "Didn't throw exception as expected";
}

TEST(PluginlibTest, brokenPlugin)
{
  pluginlib::ClassLoader<test_base::Fubar> test_loader("pluginlib", "test_base::Fubar");
  test_base::Fubar* none = NULL;

  try {
    none = test_loader.createUnmanagedInstance("pluginlib/none");
    none->initialize(10.0);
  } catch (pluginlib::PluginlibException & ex) {
    SUCCEED();
    return;
  } catch (class_loader::ClassLoaderException& ex) {
    FAIL() << "class_loader exception instead of pluginlib, argh. " << ex.what() << "\n";
  } catch (...) {
    FAIL() << "Uncaught exception";
  }
  ADD_FAILURE() << "Didn't throw exception as expected";
}

TEST(PluginlibTest, workingPlugin)
{
  pluginlib::ClassLoader<test_base::Fubar> test_loader("pluginlib", "test_base::Fubar");
  test_base::Fubar* foo = NULL;

  try {
    foo = test_loader.createUnmanagedInstance("pluginlib/foo");
    foo->initialize(10.0);
    EXPECT_EQ(foo->result(),100.0);
  } catch (pluginlib::PluginlibException & ex) {
    FAIL() << "Throwing exception: " << ex.what();
    return;
  } catch (...) {
    FAIL() << "Uncaught exception";
  }
}

TEST(PluginlibTest, createUnmanagedInstanceAndUnloadLibrary)
{
  ROS_INFO( "Making the ClassLoader..." );
  pluginlib::ClassLoader<test_base::Fubar> pl("pluginlib", "test_base::Fubar");

  ROS_INFO( "Instantiating plugin..." );
  test_base::Fubar *inst = pl.createUnmanagedInstance("pluginlib/foo");

  ROS_INFO( "Deleting plugin..." );
  delete inst;

  ROS_INFO( "Checking if plugin is loaded with isClassLoaded..." );
  if( pl.isClassLoaded( "pluginlib/foo" ) ) {
    ROS_INFO( "Class is loaded" );
  } else {
    FAIL() <<  "Library containing class should be loaded but isn't.";
  }
  ROS_INFO( "Trying to unload class with unloadLibraryForClass..." );
  try {
    pl.unloadLibraryForClass("pluginlib/foo");
  } catch (pluginlib::PluginlibException & e) {
    FAIL() << "Could not unload library when I should be able to.";
  }
  ROS_INFO( "Done." );
}

TEST(PluginlibTest, createManagedInstanceAndUnloadLibrary)
{
  ROS_INFO( "Making the ClassLoader..." );
  pluginlib::ClassLoader<test_base::Fubar> pl("pluginlib", "test_base::Fubar");

  ROS_INFO( "Instantiating plugin..." );
  {
    pl.createInstance("pluginlib/foo");
  }

  ROS_INFO( "Checking if plugin is loaded with isClassLoaded..." );
  if( pl.isClassLoaded( "pluginlib/foo" ) ) {
    ROS_INFO( "Class is loaded" );
  } else {
    FAIL() <<  "Library containing class should be loaded but isn't.";
  }

  ROS_INFO( "Trying to unload class with unloadLibraryForClass..." );
  try {
    pl.unloadLibraryForClass("pluginlib/foo");
  } catch (pluginlib::PluginlibException & e) {
    FAIL() << "Could not unload library when I should be able to.";
  }
  ROS_INFO( "Done." );
}

// Run all the tests that were declared with TEST()
int main(int argc, char **argv){
  ::testing::AddGlobalTestEnvironment(new CustomEnvironment());
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
